#include <iostream>
#include <queue>
using namespace std;

struct cmp {
	bool operator()(pair<int, int> a, pair<int, int> b) {
		return a.first < b.first;
	}
};

int V, E;
int INF = 987654321;
vector<pair<int, int>> graph[20001];
int dist[20001]; // dist[i]는 시작 도시부터 도시 i까지의 최단 거리
priority_queue < pair<int, int>, vector<pair<int, int>>, cmp> pq;
// pq.push({a,b}) 는 {시작 도시부터 도시 b까지의 최단거리, 현재 도시 번호} 를 의미함
int K;

void dijstra() {
	dist[K] = 0; // 시작 도시의 최단 거리는 0
	pq.push({ 0,K }); 

	while (!pq.empty()) { // 우선순위 큐가 빌 때 까지
		int len = pq.top().first;
		int now = pq.top().second;
		pq.pop();

		if (dist[now] < len) // 이미 처리한 노드라면
			continue;
		
		for (int i = 0; i < graph[now].size(); i++) {
			if (graph[now][i].second != 0) { // 경로가 존재할 때
				if (dist[graph[now][i].first] > len + graph[now][i].second) { // 갱신이 필요하다면
					dist[graph[now][i].first] = len + graph[now][i].second;
					pq.push({ dist[graph[now][i].first],graph[now][i].first });
				}
			}
		}
	}
}


int main() {
	cin >> V >> E; // 정점, 간선의 개수
	cin >> K; // 시작 도시의 번호
	for (int i = 0; i < E; i++) { // 간선 정보 입력
		int start, end, dist;
		scanf("%d %d %d", &start, &end, &dist);
		graph[start].push_back({ end,dist });
	}

	for (int i = 1; i <= V; i++) // 최단 거리 배열 초기화
		dist[i] = INF;

	dijstra();

	for (int i = 1; i <= V; i++) { // 출력 포맷
		if (dist[i] == INF)
			printf("INF \n");
		else
			printf("%d \n", dist[i]);
	}
}