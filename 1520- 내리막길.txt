#include <iostream>
using namespace std;

// (0,0)에서 (M-1,N-1)까지

int M, N;
int result;
int dx[] = { -1,1,0,0 };
int dy[] = { 0,0,-1,1 };
int map[501][501];
int dp[501][501]; // dp[i][j]는 (i,j)로 갈 수 있는 경로의 경우의 수


int dfs(int x, int y) { // 모든 경우에 대해서 반환값을 입력해야함

	if (x == M - 1 && y == N - 1) // 목표 지점에 도착했을때
		return 1;

	if (dp[x][y] != -1) // 이미 방문한 곳이면 계산할 필요 없음
		return dp[x][y];

	dp[x][y] = 0; // **중요** 방문하지 않았다면 0으로 방문 처리, 추후에 값 계산됌

	for (int i = 0; i < 4; i++) {
		int nx = x + dx[i];
		int ny = y + dy[i];

		if (nx >= 0 && nx <= M - 1 && ny >= 0 && ny <= N - 1) {
			if (map[x][y] > map[nx][ny]) { // 내리막길이면
				dp[x][y] += dfs(nx, ny);
			}
		}
	}
	return dp[x][y]; // **중요** 모든 과정이 끝나면 반환
}

int main() {
	cin >> M >> N;
	for (int i = 0; i < M; i++)
		for (int j = 0; j < N; j++)
			scanf("%d", &map[i][j]);

	for (int i = 0; i < M; i++)
		for (int j = 0; j < N; j++) // dp[i][j]가 0이면 방문한 건지 경로가 없는건지 구분할 수 없다
			dp[i][j] = -1;

	cout << dfs(0, 0);
}